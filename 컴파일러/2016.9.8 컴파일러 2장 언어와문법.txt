: = | (or)

A -> abBc : cBa : d
B -> bc:e  (위에 B에 끼워 넣을 수 있음) 가장 길이가 짧은건 e B가 있는곳 아무곳이나 넣을 수 있음 (CFG(?))
문맥의존문법 추가
bB -> bbcA (화살표 왼쪽이 nonterminal 하나만 와야하느냐? 그건 아님) nonterminal 아닌놈이 있으면
CSG(문맥의존문법) 단 이경우에는 bB(왼쪽 문맥 b를 봐야함) 즉 앞에 abBc에만 적용할수 있음
Ba -> ba 이 경우는 cBa 이경우에만 적용 가능 또한 길이를 봐야하는데
bB->bbCa 경우 2<=4 이므로 가능 Ba->ba의 경우 2<=2 이므로 가능
만약 이걸 만족 안하면(Ba -> a) 무제한문법(UG)로 넘어감 그럼 왜 작아지는거 허용 안할가? 만약 작아지면 
우리가 시작기호로부터 일반적으론 길어지는게 목적인데 줄어지면 이상함 자연스럽지 못함 (엡실론 생성규칙은
예외적으로 허용해주지만 일반적으론 만약 엡실론 생성규칙을 허용안하면 가능하긴하지만 매우 어려워짐)
c -> cc

L1 = {0,1,00,01,10,11, ...}
S -> 0:1:0S:1S

순환규칙(recursive rule)

A->aAb:c     -     CFG임 (contextfreegrammer) 양옆에 달고나오거나 섞여있거나

A=>aAb=>aaAbb ..... n번적용 ...... a.....aAb.....b
			    --------> 가장최근<-------

CFG a의n승b의n승 <- 문맥자유문법
정규문법
S->AB
문법이틀린건 아니나 정규문법이 아니라
그렇다면 정규문법으로 기술해야함
a의m승b의n승, m,n>=1
A->aA:a -> a의 m승
B->bB:b -> b의 n승
머리를써서 어떻게?
A->aA:a:B <- a^m b^n
A->aA:a:bB:b 
	(B만 쓰면 안됨 단일생성규칙에 허용 안해서)
B->bB:b

m,n>=0으로 바꾸면?
A->aA:ε(엡실론):bB:ε
A->aA:bB:ε
B->bB:ε
ε<-편의상 허용해줌 (NULL값, 아무것도없는거)
아무튼 간단한 문제가 아님
ε 설명
만약 a의0승 b의 1승 이면 b a의0승b의0승 이면 ε