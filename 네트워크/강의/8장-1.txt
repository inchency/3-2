1.암호 - 제 3자에 대한 방어
2.인증(pw, OTP) 보안카드(랜덤넘버 난수표), 공인인증서USB
3. 무결성 - 싸인, 도장
byte(1024bit)키 - 수퍼컴퓨터 1년
byte(2048)키 - 슈퍼컴퓨터 2년이 아니라 1년의 1024승
가급적 긴 키를 쓰면 좋지 않느냐? 왜 긴거 안씀?
너무 길다고해서 좋은건아님(계산시간이 소모가 크고, 시기를놓칠 수 있는 단점이 있음)
암호의 난이도를 요구하는 상황에 맞게끔 쓰는게 좋음
계약할때 하나의 오차 없이 증명해주는 기술을 무결성이라고함

2,3은 당사자들에 대한 방어 (상대편이 맞는지) 서로에 대한 방어를하는것
이 세개가 필수 

p5 보면
중간에 Trudy가 가로채는걸 막기위해 암호화cryptography
그런데 정보를 가로챌순없어도 가는걸 막아버릴순 있음 이건 위험 이거만큼은 쉽게 해결하기 어려움
그나마 다행이라면 trudy는 내용을 모름
빨강색 = 채널
흘러가는건 = 순수한 데이터
컨트롤은 잘 가라고 보조적인 메세지 정보
p7
eavesdrop = 도청 = 감청한다.
insert = 없는 메세지를 만듦 (가짜메세지를 투입)
impersonation = 위장(자기가 alice인것처럼 위장)
hijacking = 지나가지 못하게 막아버림
denial of service = (Ddos) 메모리를 많이 잡아먹게해서 시스템 다운시킴
왜 d가 하나가 없을까? distributed임 맨앞에꺼 d는
1초동안 수천개의 request를 보냄 마치 손님인것처럼(가짜인데) 프로세스 메모리를할당함(시간도)
pc에서 천개의 프로세스를 동작한다고 생각하면됨(다운되겠지?)D dos 분산 dos공격
p9
key가 길면길수록 기하급수적으로 어려워짐 1비트만 늘어나도 2배가 어려워지고 2비트늘어나면 4배가 어려워짐
1024~2048비트 된다면 2의 1024승이 더 복잡해진다는것임
p10
2의10승 = 1000
2의 20=100만개
2의30=10억개
2의40=1조개
2이50 = 1조X1000
p11
대칭키 알고리즘 (암호화)
대칭키 방식의 암호화 symmetric key crypto
똑같은 알고리즘으로 
p12
전쟁터에서 쓰이는 알고리즘(맵핑시키는거)
비교적 짧은 시간에 사라짐 substitution algorithm
쪼금더 어렵게 한다면?
p13
임
p14
DES Data Encryption Standard 23년전에 표준화가 완료됨 1993년
키의 사이즈 56비트 <- 너무 취약함 안씀
그때 당시엔 나름괜찮았음 15p보면 알고리즘나와있음
8개의 char 들어온걸 토막을내서
8바이트 이알고리즘돌림 카드섞듯이 셔플링을함
16단계를 진행하는데도 취약함
permutation 섞는다는뜻
p16
DES가 취약해서 나온게 AES방식
진화된 새로운 암호화 알고리즘 Advanced Encryption Standard
8년후에 나옴 2001년 256키까지 (128,192,256) bit keys
149 trillion years 한 시간이 있어야 풀림

p17
비대칭키
Ka, Kb 하나는 전국민을 대상으로 open함 그래서 이걸 공개키라고함(심지어 범죄자에게도 누구에게나)
반대편 Ka는 혼자만 앎(본인만)
여기선 private key= 기밀, public key = 공공키
p18
한쌍의 키이긴 하지만 여기선 bob이란 사람이 가지고 있는 한쌍의 key
하나는 전세계 인류를 향해 open 되어 있음 나머지 하나는 bob이란 사람만 알고있음
alice가 bob한테 private한 메세지를 보내려함. bob이 가지고 있는 private키로만 메세지를 열수 있게끔
암호를 거는것임(만든 사람 조차도 암호를 풀 수 없음) 만든사람은 메세지는 알지만 암호는 못품
이때엘리스가 적용하는 key는 전세계가 쓰는 open키를 씀
kb+ 공개키로 암호화하면 bob의 kb-비밀키로만 풀 수 있음
목적지가 bob이라고하면 분실하지 않는 이상 kb-를 가지고있음
만약 공인인증서 잃어버리면 빨리 분실신고해야함 인감증명이 취소된거니까


공개키 방식 = 공인인증서 (양쪽키가 똑같이생김)
